/**
 *	@overview JS Implementation of xPlaces protocol.
 *	Based on xpNetwork and xpDeviceImpl C++ classes
 *
 *	@copyright <a href="http://www.crs4.it">CRS4 2013</a>
 *	@author Simone Kalb <kalb@crs4.it>
 *	@author Gian Maria Simbula <simbula@crs4.it>
 *
 *	@summary: Original work by Gian Maria Simbula
 *	eMail: simbula@sardegnaricerche.it
 *	eMail: simbula@crs4.it
 */

/** 
 *	@constant
 *  @type {number}
 *  @description XP_ANNOUNCE defines an xpAnnounce message type, referring to xPlaces protocol
 *  @default 1
 */
var XP_ANNOUNCE = 1;

/** 
 *	@constant
 *  @type {number}
 *  @description XP_EVENT defines an xpEvent message type, referring to xPlaces protocol
 *  @default 2
 */
var XP_EVENT = 2;

/** 
 *	@constant
 *  @type {number}
 *  @description XP_ACTION defines an xpAction message type, referring to xPlaces protocol
 *  @default 3
 */
var XP_ACTION = 3;

/** 
 *	@constant
 *  @type {number}
 *  @description XP_ADD_LISTENER defines an xpAddEventListerner message type, referring to xPlaces protocol
 *  @default 4
 */
var XP_ADD_LISTENER = 4;

/** 
 *	@constant
 *  @type {number}
 *  @description XP_REMOVE_LISTENER defines an xpRemoveEventListerner message type, referring to xPlaces protocol
 *  @default 5
 */
var XP_REMOVE_LISTENER = 5;

//var serverIPPort;
//var localIP;
//var configurationFile;

var dgram = require("dgram");
var xpTools = require('xpTools');
var http = require("http");

/**
 * xpNode creates a node of an xPlaces network.
 * @method xpNode
 * @param  {integer}     id An preogressive input integer, used to label different xpNode(s)
 * @param  {remoteRequest}     client A remote request handler used to create the datagram socket
 * @param  {string}     configurationPathFile The path to the JSON configuration file, default is JSON/configuration.json
 *
 */
 function xpNode(name, type, client, basep, localip, serveripport) {

    this.configurationFile = "JSON/configuration.json";
    xpTools.getConfigurationData(this.configurationFile);
    
    this.localIP = localip;
    this.serverIPPort = serveripport;

    this.name = name;
    this.type = type;
    //proxy node takes always the basePort, otherwise the port will be increased
    this.port = basep;
    this.descriptor;
    this.announcesList;
    this.deadList;
    this.eventListenerList;
    this.client;
    this.client = client;
    this.intervalAnnounce;
    this.intervalEvent;
    this.announceTimeout = 5000;
};

/**
 * Clear intervals and destroy the object
 * @method delete
 *
 */
xpNode.prototype.delete = function () {
    console.log("deleted node: " + this.name);
    clearInterval(this.intervalAnnounce);
    clearInterval(this.intervalEvent);
}

xpNode.prototype.receive_packet = function(packet, objRef) 
{
    if(packet.length < 10)
        return;

    var id = packet.readUInt32BE(0);
    var total_packets = packet.readUInt16BE(4);
    var current_packet = packet.readUInt16BE(6);

    if(total_packets == 1)
    {
        var datagram = new Buffer(packet.length-8);
        packet.copy(datagram,0,8,packet.length);
        objRef.dispatcher(datagram);
    }

    else
    {
        if(objRef.map_datagram[id] == undefined)
        {
            var ctrl_datagram = new Object();
            ctrl_datagram["packet_counter"] = 1;
            ctrl_datagram["total_packets"] = total_packets;
            ctrl_datagram["packets"] = new Array();
            ctrl_datagram["packets"][current_packet] = packet;
            objRef.map_datagram[id] = ctrl_datagram;
        }
        else
        {
            var ctrl_datagram = objRef.map_datagram[id];
            if(ctrl_datagram["packets"][current_packet] == undefined)
            {
                ctrl_datagram["packets"][current_packet] = packet;
                ctrl_datagram["packet_counter"] ++;

            }

            if(ctrl_datagram["packet_counter"] == total_packets)
            {
                var round_lenght = 4088 * total_packets;

                var packet = ctrl_datagram["packets"][0];
                var total_length = packet.readUInt32BE(8);


                //xpTools.xpLog(false, "lenght check: " + total_packets + " " + " " + total_length);
                var datagram = new Buffer(total_length);


                for(var i = 0; i < total_packets - 1; i++)
                {
                    var pointer = i*4088;
                    var packet = ctrl_datagram["packets"][i];
                    packet.copy(datagram,i*4088,8,4088);
                }

                var last_length = total_length % 4088;

                var packet = ctrl_datagram["packets"][i];
                packet.copy(datagram,i*4088,8,last_length+8);
                
            

                xpTools.xpLog(false, "lenght check: " + total_packets + " " + last_length + " " + total_length);

                objRef.dispatcher(datagram);

                delete objRef.map_datagram[id];
            }
        }

    }
}

xpNode.prototype.send_datagram = function(datagram, recipientPort, recipientIP, errorStr, successStr, objRef) 
{
    var length = datagram.length;
    var datagram_id = Math.floor(Math.random() * Math.pow(2,32)) - 1;
    var num_packets = Math.floor(length / 4088) + 1;
    var current_packet = 0;
    var h_size = 8;

    var correct_size = length % 4088;

    var current_pointer = 0;

    while(current_packet < num_packets)
    {
        var size_of_packet = length < 4088 ? length : 4088;
        size_of_packet += h_size;

        var source_end = 4088;
        if(current_packet == num_packets - 1)
            source_end = correct_size;

        var packet = new Buffer(size_of_packet);
        packet.writeUInt32BE(datagram_id, 0);
        packet.writeUInt16BE(num_packets, 4);
        packet.writeUInt16BE(current_packet, 6);
        datagram.copy(packet,8,current_pointer,current_pointer+source_end);

        current_pointer += (size_of_packet - h_size);
        current_packet++;

        objRef.client.send(packet, 0, size_of_packet, recipientPort, recipientIP, function(err, bytes) {
            if(err){
                xpTools.xpLog(false, errorStr);
                objRef.client.close();
            }
        });

    }

    //xpTools.xpLog(false, "send_datagram: " + num_packets);

    //xpTools.xpLog(false, successStr);
}


/**
 * Initialize the xpNode object, setting all the environment, configuration variables and starts the logic
 * @method init
 *
 */
xpNode.prototype.init = function () { 

    var randomString = xpTools.randomString(64, true, false, false);

    this.descriptor = new Object();
    this.descriptor["device_name"] = this.name;
    this.descriptor["device_type"] = this.type;
    this.descriptor["sender_session"] = randomString;
    this.descriptor["sender_ip_port"] = "http://" + this.localIP + ":" + this.port;
    this.descriptor["recipient_ip_port"] = this.serverIPPort;
    this.descriptor["sender_type"] = this.type;
    this.descriptor["sender_name"] = this.name;
    
    if(this.device_properties) this.descriptor["device_properties"] = this.device_properties;
    

    this.map_datagram = new Object();

    xpTools.xpLog(true, "New Node: " + this.name + " type: " + this.type + " session: " + randomString);
    xpTools.xpLog(true, "Server: " + this.serverIPPort + " localIP: " + this.localIP + " Port: " + this.port);


    this.announcesList = new Array();
    this.deadList = new Array();
    this.eventListenerList = new Array();

    this.client = dgram.createSocket("udp4");

    var objRef = this;

    this.client.on("message", function (msg, rinfo) {
        objRef.receive_packet(msg, objRef);
    });

    var clientRef = this.client;
    this.client.on("listening", function () {
        address = clientRef.address();
        xpTools.xpLog(false, "Server listening " + address.address + ":" + address.port);
    });


    this.client.bind(this.port, this.localIP);

    this.intervalAnnounce = setInterval(this.announceService, this.announceTimeout, this);
};

xpNode.prototype.close = function () {
    console.log("close node: " + this.name);
	clearInterval(this.intervalAnnounce);
}

/**
 * Dispatchs the data received from xPlaces network and calls the needed callback concerning message type (XP_ANNOUNCE, XP_EVENT, XP_ACTION, XP_ADD_LISTENER, XP_REMOVE_LISTENER).
 * Used internally.
 * @method dispatcher
 * @param  {Hashtable}   properties The received datagram that contains a set of key-value pairs. When converted to hashtable, it will be forwarded to specific callback.
 *
 */
xpNode.prototype.dispatcher = function(properties) {
    var message = xpTools.datagramToHash(properties);
    switch(parseInt(message['message_type']))
    {
    case (XP_EVENT):
        this.dispatchEvent(message, this);
        break;
    case (XP_ACTION):
        this.dispatchAction(message, this);
        break;
    case(XP_ADD_LISTENER):
        this.dispatchListener(message, this);
        break;
    case(XP_REMOVE_LISTENER):
        this.dispatchRemoveListener(message, this);
        break;
    case(XP_ANNOUNCE):
        this.addAnnounce(message, this);
        break;
    default:
        xpTools.xpLog(false, "Not a known type...\n");
        break;
    }
};

/* **********************************************************************
* 						STARTING Announce code-block
********************************************************************** */
/**
 * Add a descriptor to the local descriptor list based on announce message received
 * @method addAnnounce
 * @param  {HashTable}    announce The XP_ANNOUNCE message used to update the xPlaces network node list.
 * @param  {xpNode}    objRef A reference to access the specific xpNode node list.
 */
xpNode.prototype.addAnnounce = function(announce, objRef) {

    if (objRef.descriptor["sender_ip_port"] == announce['sender_ip_port'] && objRef.descriptor["device_type"] != "XP_PROXY" || objRef.descriptor["sender_session"] == announce['sender_session']) {
        xpTools.xpLog(true, "Ghost received - discarded: " + announce['sender_session']);
        return;
    }
    
    xpTools.xpLog(false, "addAnnounce:: " + objRef.descriptor["sender_name"] + " (" + objRef.descriptor["sender_ip_port"] + ") received announce from " + " " + announce['device_name'] + " (" + announce['sender_ip_port'] + ")");

    for(var i = 0; i < objRef.deadList.length; i++) {
        //Return if announce is related to an item in deadList.
        if(announce['sender_ip_port'] == objRef.deadList[i]['sender_ip_port'] && announce['sender_session'] == objRef.deadList[i]['sender_session'])
        {
        	xpTools.xpLog(false, "addAnnounce:: " + objRef.descriptor["sender_name"] + "Renew dead node detected on ip: " + announce['device_name'] + " " + announce['sender_session']+ "\n");
        	announce["status"] = "Renew";
        	objRef.deadList.remove(i, i);
			break;
        }
    }

	//update announce time and forward message to WS node
    for(var i = 0 ; i < objRef.announcesList.length; i++) {
        var iThElement = objRef.announcesList[i];
        if(iThElement['sender_session'] == announce['sender_session']) {
            iThElement['time_stamp'] = new Date().getTime();
            xpTools.xpLog(false, "addAnnounce:: " + objRef.descriptor["sender_name"] + " has updated announce for item " + '  ' + iThElement['device_name'] + '  ' + iThElement['sender_session'] + "\n");

            //GP forward messages to WS node
            if(objRef.newAnnounce) objRef.newAnnounce(announce, objRef);
            //GPEND
            return;
        }
    }

	//server sends announce to other nodes
    if (objRef.serverIPPort == objRef.descriptor['sender_ip_port']) {
        for(var i = 0 ; i < objRef.announcesList.length; i++) {
            xpTools.xpLog(false, "addAnnounce:: " + objRef.descriptor["sender_name"] + " server send " + announce["device_name"] + " announce to other node -> " + objRef.announcesList[i]['device_name'] + " " + objRef.announcesList[i]['sender_session']);
            objRef.sendAnnounceWithSession(announce, objRef.announcesList[i]['sender_ip_port'], objRef.announcesList[i]['sender_session']);   //GP questo non mi sembra corretto
        }
    }

    xpTools.xpLog(false, "addAnnounce:: " + objRef.descriptor["sender_name"] + " detects a new node : " + announce['device_name'] + " " + announce['sender_session'] + ": new item\n");
    announce['time_stamp'] = new Date().getTime();
    objRef.announcesList.push(announce);

    //GP if announce is a new item, send it to WS node
    if(objRef.newAnnounce) 
	{
		var announceItem = announce;
		//if annouce is not "Renew"
		if(announceItem["status"] == undefined)
		{
			announceItem["status"] = "New";
			objRef.newAnnounce(announceItem, objRef);
		}
	}
    //GPEND
};

/**
 * Check for dead node in the announce list and and sends local descriptor to other nodes.
 * It's the announce interval logic code. Used internally.
 * @method announceService
 * @param  {xpNode}        objRef A reference to the specific xpNode where to start the announce service.
 *
 */
xpNode.prototype.announceService = function(objRef) {
    for (var i = objRef.announcesList.length - 1; i >= 0; i--) {
        var announceItem = objRef.announcesList[i];

        var timeDiff = new Date().getTime() - announceItem.time_stamp;

        if (timeDiff > objRef.announceTimeout) {
            xpTools.xpLog(false, "announceService:: " + objRef.descriptor["sender_name"] + " perceives dead node at " + announceItem.device_name + "(" + announceItem.sender_ip_port + ") " + announceItem.sender_session + "\n");
            objRef.deadList.push(announceItem);
            objRef.announcesList.remove(i, i);
            //GP forward messages to WS node
            announceItem["status"] = "Dead";
            if(objRef.newAnnounce) objRef.newAnnounce(announceItem, objRef);
            //GPEND
        }
    }

    //We need to send the descriptor to the server at least the first time.
    if(objRef.serverIPPort != objRef.descriptor['sender_ip_port'])
    {
        objRef.sendAnnounce(objRef.descriptor, objRef.serverIPPort);
        xpTools.xpLog(false, "announceService:: " + objRef.descriptor["sender_name"] + " (" + objRef.descriptor["sender_ip_port"] + ") sends announce to server " + objRef.serverIPPort);
    }

    for(var i = 0 ; i < objRef.announcesList.length; i++)	{
        //This descriptor must be forwarded to server if server is the proxy!
        //if(objRef.serverIPPort != objRef.announcesList[i]['sender_ip_port'])
        {
        	xpTools.xpLog(false, "announceService:: " + objRef.descriptor["sender_name"] + " (" + objRef.descriptor["sender_ip_port"] + ") sends announce to node " +  objRef.announcesList[i]['device_name']);
        	objRef.sendAnnounceWithSession(objRef.descriptor, objRef.announcesList[i]['sender_ip_port'], objRef.announcesList[i]['sender_session']);
        }
    }

    //NOTE: We have only one device in a xpNode instance
};
/**
 * Forwards the descriptor to server.
 * @method sendMessage
 * @param  {HashTable}     descriptor The descriptor hashtable to forward on the xPlaces network
 * @param  {xpNode}        objRef A reference to the specific xpNode where to start the announce service.
 *
 */
xpNode.prototype.forwardsAnnounce = function(message,objRef) {
    //We send the descriptor to the server.
    objRef.sendAnnounce(message, objRef.serverIPPort);
};

/**
 * Just send a descriptor to destination node.
 * @method sendAnnounce
 * @param  {HashTable}     descriptor The descriptor hashtable to forward on the xPlaces network
 * @param  {string}     destination The destination IP:PORT address.
 *
 */
xpNode.prototype.sendAnnounce = function(descriptor, destination) {
    // Send its own descriptor to network
    descriptor['recipient_ip_port'] = destination;
    this.announce(descriptor);
};

/**
 * Just send a descriptor to destination node.
 * @method sendAnnounceWithSession
 * @param  {HashTable}     descriptor The descriptor hashtable to forward on the xPlaces network
 * @param  {string}     destination The destination IP:PORT address.
 * @param  {string}     destinationSession The destination session.
 *
 */
xpNode.prototype.sendAnnounceWithSession = function(descriptor, destination, destinationSession) {
    // Send its own descriptor to network
    descriptor['recipient_ip_port'] = destination;
    descriptor['recipient_session'] = destinationSession;
    this.announce(descriptor);
};
/**
 * Forwards the device descriptor data through the network. Used internally.
 * @method announce
 * @param  {HashTable} device The descriptor hashtable to forward on the xPlaces network
 * @return {boolean} true if successful, false otherwise
 */
xpNode.prototype.announce = function(device) {
    device["message_type"] = XP_ANNOUNCE;
    var recipientAddress = device["recipient_ip_port"];
    // TODO xpTools.testAddress
    recipientAddress = recipientAddress.substr(7,recipientAddress.lenght);
    var recipientIP = recipientAddress.split(":")[0];
    var recipientPort = recipientAddress.split(":")[1];
    var datagram = xpTools.toByteArray(device);

    var errorStr = "[xpNode sending announce] Unable to send datagram\n";

    this.send_datagram(datagram, recipientPort, recipientIP, errorStr, "", this);

    /*this.client.send(datagram, 0, datagram.length, recipientPort, recipientIP, function(err, bytes) {
        if(err){
            xpTools.xpLog(false, "[xpNode sending announce] Unable to send datagram\n");
            this.client.close();
        }

    });*/

    return true;
};

/* **********************************************************************
* 						ENDING Announce code-block
********************************************************************** */




/* **********************************************************************
* 						STARTING Action code-block
********************************************************************** */
/**
 * Just logs if the node is receiving an action.
 * You must overrite it for a most specialized behaviour when
 * an acion has been received.
 * @method dispatchAction
 * @param  {HashTable}       action The action hashtable received from the xPlaces network
 * @param  {xpNode}       objRef A reference to the specific xpNode used to check if session code matchs.
 *
 */
xpNode.prototype.dispatchAction = function(action, objRef) {
    if(action['recipient_session'] == objRef.descriptor['sender_session']) {
        xpTools.xpLog(false, "Action Received");
    }
}

/**
 * Forwards an action to destinations node. Used internally.
 * @method sendActionByProxy
 * @param  {Hashtable}          destinationNode The destination node xpDescriptor as hashtable.
 * @param  {Hashtable}          xpAction The action hashtable to forward on the xPlaces network
 * @param  {xpNode}          objRef A reference to access a specific xpNode datagram socket
 *
 */
xpNode.prototype.sendActionByProxy = function(destinationNode, xpAction, objRef) {
    if(destinationNode != null) {
        //Adding specific properties of xpAction to passed key:value list
        xpAction["message_type"] = XP_ACTION;
        xpAction["sender_ip_port"] = objRef.descriptor["sender_ip_port"];
        xpAction["sender_session"] = objRef.descriptor["sender_session"];
        xpAction["recipient_ip_port"] = destinationNode["sender_ip_port"];
        xpAction["recipient_session"] = destinationNode["sender_session"];

        var recipientAddress = xpAction["recipient_ip_port"];
        // TODO xpTools.testAddress
        recipientAddress = recipientAddress.substr(7,recipientAddress.lenght);
        var recipientIP = recipientAddress.split(":")[0];
        var recipientPort = recipientAddress.split(":")[1];
        //xpTools.printHash(xpAction);
        var datagram = xpTools.toByteArray(xpAction);

        var errorstr = "[xpNode sending action by name] Unable to send datagram\n";

        objRef.send_datagram(datagram, recipientPort, recipientIP, errorstr, "", objRef);

        /*objRef.client.send(datagram, 0, datagram.length, recipientPort, recipientIP, function(err, bytes) {
            if(err){
                xpTools.xpLog(false, "[xpNode sending action by name] Unable to send datagram\n");
                objRef.client.close();
            }
            //xpTools.xpLog(false, "Action sent to " + destinationNode["sender_ip_port"] + "!\n");
        });*/
    }
}

/**
 * Sends an xpAction to the destination node referring by its name
 * @method sendActionByName
 * @param  {string}         destinationName The destination node name to forward the action
 * @param  {HashTable}         xpAction The action hashtable to forward on the xPlaces network
 * @param  {xpNode}         objRef A reference to access a specific xpNode datagram socket
 *
 */
xpNode.prototype.sendActionByName = function(destinationName, xpAction, objRef) {

    /* ************************************************
    **  TODO Set a time limit or a iterations limit  **
    **************************************************/

    var iterations = 0;

    var nonBlockingSendingFunc = function(destinationName, xpAction, objRef, callback, iterations) {
        if(iterations <= 10) {
            var destination = objRef.lookupDevice(destinationName, objRef);
            if(destination != null) {
                //Adding specific properties of xpAction to passed key:value list
                xpAction["message_type"] = XP_ACTION;
                xpAction["sender_ip_port"] = objRef.descriptor["sender_ip_port"];
                xpAction["sender_session"] = objRef.descriptor["sender_session"];
                xpAction["recipient_ip_port"] = destination["sender_ip_port"];
                xpAction["recipient_session"] = destination["sender_session"];

                var recipientAddress = xpAction["recipient_ip_port"];
                // TODO xpTools.testAddress
                recipientAddress = recipientAddress.substr(7,recipientAddress.lenght);
                var recipientIP = recipientAddress.split(":")[0];
                var recipientPort = recipientAddress.split(":")[1];
                var datagram = xpTools.toByteArray(xpAction);

                var errorStr = "[xpNode sending action by name] Unable to send datagram\n";
                var successStr = "Action sent to " + destinationName + "!\n";

                objRef.send_datagram(datagram, recipientPort, recipientIP, errorStr, successStr, objRef);

                /*objRef.client.send(datagram, 0, datagram.length, recipientPort, recipientIP, function(err, bytes) {
                    if(err){
                        xpTools.xpLog(false, "[xpNode sending action by name] Unable to send datagram\n");
                        objRef.client.close();
                    }
                    xpTools.xpLog(false, "Action sent to " + destinationName + "!\n");

                });*/
            } else {
                iterations++;
                setTimeout(callback, 1000, destinationName, xpAction, objRef, callback, iterations);
            }
        }
    }

    setTimeout(nonBlockingSendingFunc, 1, destinationName, xpAction, objRef, nonBlockingSendingFunc, iterations);
}

/**
 * Sends an xpAction to a set of destination nodes referring by their type
 * @method sendActionByName
 * @param  {string}         destinationType The device type to check for the destination nodes.
 * @param  {HashTable}         xpAction The action hashtable to forward on the xPlaces network
 * @param  {xpNode}         objRef A reference to access a specific xpNode datagram socket
 *
 */
xpNode.prototype.sendActionByType = function(destinationType, xpAction, objRef) {

    /* ************************************************
    **  TODO Set a time limit or a iterations limit  **
    **************************************************/

    var iterations = 0;
    var nonBlockingSendingFunc = function(destinationType, xpAction, objRef, callback, iterations) {
        if(iterations <= 10) {
            var destinationList = objRef.lookupDevices(destinationType, objRef);
            if(destinationList != null) {
                //Adding specific properties of xpAction to passed key:value list
                xpAction["message_type"] = XP_ACTION;
                xpAction["sender_ip_port"] = objRef.descriptor["sender_ip_port"];
                xpAction["sender_session"] = objRef.descriptor["sender_session"];

                for(var i = 0; i < destinationList.length; i++) {
                    xpAction["recipient_ip_port"] = destinationList[i].sender_ip_port;
                    xpAction["recipient_session"] = destinationList[i].sender_session;

                    var recipientAddress = xpAction["recipient_ip_port"];
                    // TODO xpTools.testAddress
                    recipientAddress = recipientAddress.substr(7,recipientAddress.length);
                    var recipientIP = recipientAddress.split(":")[0];
                    var recipientPort = recipientAddress.split(":")[1];
                    var datagram = xpTools.toByteArray(xpAction);

                    var errorStr = "[xpNode sending action by type] Unable to send datagram\n";
                    var successStr = "";

                    objRef.send_datagram(datagram, recipientPort, recipientIP, errorStr, successStr, objRef);

                    /*objRef.client.send(datagram, 0, datagram.length, recipientPort, recipientIP, function(err, bytes) {
                        if(err){
                            xpTools.xpLog(false, "[xpNode sending action by type] Unable to send datagram\n");
                            objRef.client.close();
                        }
                    });*/
                }
                xpTools.xpLog(false, "Action sent to " + destinationList.length + " nodes of type " + destinationType + "!\n");
            } else {
                iterations++;
                setTimeout(callback, 1000, destinationType, xpAction, objRef, callback, iterations);
            }
        }
    }

    setTimeout(nonBlockingSendingFunc, 1, destinationType, xpAction, objRef, nonBlockingSendingFunc, iterations);
}

/* **********************************************************************
* 						ENDING Action code-block
********************************************************************** */

/* **********************************************************************
* 						STARTING Event Listener code-block
********************************************************************** */
/**
 * Adds a listener to the eventListenerList based on eventTypeMask.
 * Used internally.
 *
 * @method dispatchListener
 * @param  {Hashtable}         eventListener The eventListener description to add in internal list.
 * @param  {xpNode}         objRef A reference to a specific xpNode instance.
 *
 */
xpNode.prototype.dispatchListener = function(eventListener, objRef) {
    eventListener['timeStamp'] = new Date().getTime();
    if(eventListener['recipient_session'] == objRef.descriptor['sender_session']) {
        //We have to check if eventListener is already listening for some event, if so, we need to update the related event mask.
        var foundListener = false;
        for(var i = 0; i < objRef.eventListenerList.length; i++) {
            if(eventListener['sender_ip_port'] == objRef.eventListenerList[i].sender_ip_port && eventListener['sender_session'] == objRef.eventListenerList[i].sender_session) {
                objRef.eventListenerList[i].eventTypeMask = objRef.eventListenerList[i].eventTypeMask | eventListener['eventTypeMask'];
                xpTools.xpLog(false, "Updating eventListener mask on IP " + eventListener['sender_ip_port'] + " and session " + eventListener['sender_session'] + "\n");
                foundListener = true;
                break;
            }
        }

        if(!foundListener) {
            xpTools.xpLog(false, "New eventListener on ip " + eventListener['sender_ip_port'] + " and session " + eventListener['sender_session'] + "\n");
            objRef.eventListenerList.push(eventListener);
        }

    } else {
        //Someone asked for a different session: forward removeListener to WS proxy
        if(objRef.addListener) objRef.addListener(eventListener, objRef);
    }
};
/**
 * Removes an listener from the eventListenerList based on eventTypeMask.
 * Used internally
 * @method dispatchRemoveListener
 * @param  {Hashtable}               eventListener The eventListener to remove from internal list.
 * @param  {xpNode}               objRef A reference to a specific xpNode instance.
 *
 */
xpNode.prototype.dispatchRemoveListener = function(eventListener, objRef) {
    if(eventListener['recipient_session'] == objRef.descriptor['sender_session']) {
        xpTools.xpLog(false, "IP " + objRef.descriptor['sender_ip_port'] + " has " + objRef.eventListenerList.length + " listeners\n");
        for(var i = 0; i < objRef.eventListenerList.length; i++) {
            if(objRef.eventListenerList[i].sender_session == eventListener.sender_session) {
                objRef.eventListenerList[i].eventTypeMask = xpTools.XOR(objRef.eventListenerList[i].eventTypeMask, eventListener.eventTypeMask);
                if(objRef.eventListenerList[i].eventTypeMask == 0x0){
                    objRef.eventListenerList.remove(i,i);
                    xpTools.xpLog(false, "Removing eventListener on IP " + objRef.descriptor['sender_ip_port'] + "\n");
                    xpTools.xpLog(false, "\tNow IP " + objRef.descriptor['sender_ip_port'] + " has " + objRef.eventListenerList.length + " listeners\n");
                } else {
                    xpTools.xpLog(false, "Removing type: " + eventListener.eventTypeMask + " for eventListener on IP " + eventListener['sender_ip_port'] + "\n");
                }
            }
        }
    } else {
        //Someone asked for a different session: forward removeListener to WS proxy
        if(objRef.removeListener) objRef.removeListener(eventListener, objRef);
    }
};
/**
 * Send a request to listen an eventType from a specified node referring to its name
 * @method listenDevice
 * @param  {string}     deviceName The device name to listen.
 * @param  {string}     eventTypeMask The event type to listen.
 * @param  {xpNode}     objRef A reference to access a specific xpNode datagram socket.
 *
 */
xpNode.prototype.listenDevice = function(deviceName, eventTypeMask, objRef) {
    var iterations = 0;
    var nonBlockingSendingFunc = function(deviceName, objRef, callback, iterations) {
        if(iterations <= 10) {
            var destination = objRef.lookupDevice(deviceName, objRef);
            if(destination != null) {
                var listener = new Object();
                listener["message_type"] = XP_ADD_LISTENER;
                listener["sender_ip_port"] = objRef.descriptor["sender_ip_port"];
                listener["sender_session"] = objRef.descriptor["sender_session"];
                listener["recipient_ip_port"] = destination["sender_ip_port"];
                listener["recipient_session"] = destination["sender_session"];
                listener["eventTypeMask"] = eventTypeMask;
                var recipientAddress = listener["recipient_ip_port"];
                recipientAddress = recipientAddress.substr(7,recipientAddress.lenght);
                var recipientIP = recipientAddress.split(":")[0];
                var recipientPort = recipientAddress.split(":")[1];
                var datagram = xpTools.toByteArray(listener);
        
                var errorStr = "[xpNode sending listener by name] Unable to send datagram\n";
                var successStr = "Listener sent to " + deviceName + "!\n";

                objRef.send_datagram(datagram, recipientPort, recipientIP, errorStr, successStr, objRef);

                /*objRef.client.send(datagram, 0, datagram.length, recipientPort, recipientIP, function(err, bytes) {
                    if(err){
                        xpTools.xpLog(false, "[xpNode sending listener by name] Unable to send datagram\n");
                        objRef.client.close();
                    }
                    xpTools.xpLog(false, "Listener sent to " + deviceName + "!\n");

                });*/
            } else {
                iterations++;
                setTimeout(callback, 1000, deviceName, objRef, callback, iterations);
            }
        }
    }

    setTimeout(nonBlockingSendingFunc, 1, deviceName, objRef, nonBlockingSendingFunc, iterations);

};
/**
 * Send a request to listen an eventType from a specified set of nodes referring to their type
 * @method listenDevice
 * @param  {string}     deviceType The device type to listen. It indicates a set of devices.
 * @param  {string}     eventTypeMask The event type to listen.
 * @param  {xpNode}     objRef A reference to access a specific xpNode datagram socket.
 *
 */
xpNode.prototype.listenDevices = function(deviceType, eventTypeMask, objRef) {
    var iterations = 0;
    var nonBlockingSendingFunc = function(deviceType, objRef, callback, iterations) {
        if(iterations <= 10) {
            var destinationList = objRef.lookupDevices(deviceType, objRef);
            if(destinationList != null) {
                //Adding specific properties of xpAction to passed key:value list
                var listener = new Object();
                listener["message_type"] = XP_ADD_LISTENER;
                listener["sender_ip_port"] = objRef.descriptor["sender_ip_port"];
                listener["sender_session"] = objRef.descriptor["sender_session"];
                listener["eventTypeMask"] = eventTypeMask;
                for(var i = 0; i < destinationList.length; i++) {
                    listener["recipient_ip_port"] = destinationList[i].sender_ip_port;
                    listener["recipient_session"] = destinationList[i].sender_session;

                    var recipientAddress = listener["recipient_ip_port"];
                    // TODO xpTools.testAddress
                    recipientAddress = recipientAddress.substr(7,recipientAddress.length);
                    var recipientIP = recipientAddress.split(":")[0];
                    var recipientPort = recipientAddress.split(":")[1];
                    var datagram = xpTools.toByteArray(listener);

                    var errorStr = "[xpNode sending Listener by type] Unable to send datagram\n";
                    var successStr = "";

                    objRef.send_datagram(datagram, recipientPort, recipientIP, errorStr, successStr, objRef);

                    /*objRef.client.send(datagram, 0, datagram.length, recipientPort, recipientIP, function(err, bytes) {
                        if(err){
                            xpTools.xpLog(false, "[xpNode sending Listener by type] Unable to send datagram\n");
                            objRef.client.close();
                        }
                    });*/
                }
                xpTools.xpLog(false, "Listener sent to " + destinationList.length + " nodes of type " + deviceType + "!\n");
            } else {
                iterations++;
                setTimeout(callback, 1000, deviceType, objRef, callback, iterations);
            }
        }
    }

    setTimeout(nonBlockingSendingFunc, 1, deviceType, objRef, nonBlockingSendingFunc, iterations);
};

/**
 * Stop listening to a deviceName by removing itself from remote eventListenerList
 * @method stopListenDevice
 * @param  {string}         deviceName The device name of the device to stop listening
 * @param  {xpNode}         objRef A reference to access a specific xpNode datagram socket.
 *
 */
xpNode.prototype.stopListenDevice = function(deviceName, objRef) {
    var iterations = 0;
    var nonBlockingSendingFunc = function(deviceName, objRef, callback, iterations) {
        if(iterations <= 10) {
            var destination = objRef.lookupDevice(deviceName, objRef);
            if(destination != null) {
                var listener = new Object();
                listener["message_type"] = XP_REMOVE_LISTENER;
                listener["sender_ip_port"] = objRef.descriptor["sender_ip_port"];
                listener["sender_session"] = objRef.descriptor["sender_session"];
                listener["recipient_ip_port"] = destination["sender_ip_port"];
                listener["recipient_session"] = destination["sender_session"];
                listener["eventTypeMask"] = eventTypeMask;
                var recipientAddress = listener["recipient_ip_port"];
                recipientAddress = recipientAddress.substr(7,recipientAddress.lenght);
                var recipientIP = recipientAddress.split(":")[0];
                var recipientPort = recipientAddress.split(":")[1];
                var datagram = xpTools.toByteArray(listener);

                var errorStr = "[xpNode removing listener by name] Unable to send datagram\n";
                var successStr = "Listener removed to " + deviceName + "!\n";

                objRef.send_datagram(datagram, recipientPort, recipientIP, errorStr, successStr, objRef);

                /*objRef.client.send(datagram, 0, datagram.length, recipientPort, recipientIP, function(err, bytes) {
                    if(err){
                        xpTools.xpLog(false, "[xpNode removing listener by name] Unable to send datagram\n");
                        objRef.client.close();
                    }
                    xpTools.xpLog(false, "Listener removed to " + deviceName + "!\n");
                });*/
            } else {
                iterations++;
                setTimeout(callback, 1000, deviceName, objRef, callback, iterations);
            }
        }
    }

    setTimeout(nonBlockingSendingFunc, 1, deviceName, objRef, nonBlockingSendingFunc, iterations);
};
/**
 * Stop listening to a set of devices, referring to their type, by removing itself from remote eventListenerLists
 * @method stopListenDevice
 * @param  {string}         deviceType The device type to stop listening. It indicates a set of devices.
 * @param {string} 			eventTypeMask The event type to stop listening.
 * @param  {xpNode}         objRef A reference to access a specific xpNode datagram socket.
 *
 */
xpNode.prototype.stopListenDevices = function(deviceType, eventTypeMask, objRef) {
    var iterations = 0;
    var nonBlockingSendingFunc = function(deviceType, objRef, callback, iterations) {
        if(iterations <= 10) {
            var destinationList = objRef.lookupDevices(deviceType, objRef);

            if(destinationList != null) {
                //Adding specific properties of xpAction to passed key:value list
                var listener = new Object();
                listener["message_type"] = XP_REMOVE_LISTENER;
                listener["sender_ip_port"] = objRef.descriptor["sender_ip_port"];
                listener["sender_session"] = objRef.descriptor["sender_session"];
                listener["eventTypeMask"] = eventTypeMask;

                for(var i = 0; i < destinationList.length; i++) {
                    listener["recipient_ip_port"] = destinationList[i].sender_ip_port;
                    listener["recipient_session"] = destinationList[i].sender_session;

                    var recipientAddress = listener["recipient_ip_port"];
                    // TODO xpTools.testAddress
                    recipientAddress = recipientAddress.substr(7,recipientAddress.length);
                    var recipientIP = recipientAddress.split(":")[0];
                    var recipientPort = recipientAddress.split(":")[1];
                    var datagram = xpTools.toByteArray(listener);

                    var errorStr = "[xpNode removing Listener by type] Unable to send datagram\n";
                    var successStr = "";

                    objRef.send_datagram(datagram, recipientPort, recipientIP, errorStr, successStr, objRef);

                    /*objRef.client.send(datagram, 0, datagram.length, recipientPort, recipientIP, function(err, bytes) {
                        if(err){
                            xpTools.xpLog(false, "[xpNode removing Listener by type] Unable to send datagram\n");
                            objRef.client.close();
                        }
                    });*/
                }
                xpTools.xpLog(false, "Listener removed to " + destinationList.length + " nodes of type " + deviceType + "!\n");
            } else {
                iterations++;
                setTimeout(callback, 1000, deviceType, objRef, callback, iterations);
            }
        }
    }

    setTimeout(nonBlockingSendingFunc, 1, deviceType, objRef, nonBlockingSendingFunc, iterations);
};

/* **********************************************************************
* 						ENDING Event Listener code-block
********************************************************************** */

/* **********************************************************************
* 						STARTING Event code-block
********************************************************************** */


/**
 * Notify all listeners that a new event is raised
 * @method notifyListeners
 * @param  {HashTable}        event The event to forward on xPlaces network.
 *
 */
xpNode.prototype.notifyListeners = function(event) {
    event['sender_ip_port'] = this.descriptor['sender_ip_port'];
    event['sender_session'] = this.descriptor['sender_session'];
    event['sender_type'] = this.descriptor['sender_type'];
    event['sender_name'] = this.descriptor['sender_name'];
    event['message_type'] = XP_EVENT;
    for (var i = 0; i < this.eventListenerList.length; i++){
        if(event.__event_type & this.eventListenerList[i].eventTypeMask){
            event['recipient_session'] = this.eventListenerList[i].sender_session;
            event['recipient_ip_port'] = this.eventListenerList[i].sender_ip_port;
            this.xpEvent(event);
        }
    }
} 

/**
 * Forwards	an xpEvent to the recipient listener. Used internally
 * @method xpEvent
 * @param  {Hashtable} xpEvent The event to forward on xPlaces network.
 * @return {boolean} true if success, false otherwise
 */
xpNode.prototype.xpEvent = function(xpEvent) {
    xpEvent["message_type"] = XP_EVENT;
    var recipientAddress = xpEvent["recipient_ip_port"];
    // TODO xpTools.testAddress
    recipientAddress = recipientAddress.substr(7,recipientAddress.lenght);
    var recipientIP = recipientAddress.split(":")[0];
    var recipientPort = recipientAddress.split(":")[1];
    var datagram = xpTools.toByteArray(xpEvent);

    var errorStr = "[xpNode sending event] Unable to send datagram\n";
    var successStr = "";

    this.send_datagram(datagram, recipientPort, recipientIP, errorStr, successStr, this);

    /*this.client.send(datagram, 0, datagram.length, recipientPort, recipientIP, function(err, bytes) {
        if(err){
            xpTools.xpLog(false, "[xpNode sending event] Unable to send datagram\n");
            this.client.close();
        }
    });*/

    return true;
};

/**
 * Dispatch received event. Overwrite it to implement your own logic.
 * @method dispatchEvent
 * @param  {HashTable}      xpEvent The received XP_EVENT hashtable.
 * @param  {xpNode}      objRef A reference to access a specific xpNode datagram socket.
 *
 */
xpNode.prototype.dispatchEvent = function(xpEvent, objRef) {
    if(xpEvent['recipient_session'] == objRef.descriptor['sender_session']) {
        xpTools.xpLog(false, "Event Received\n");
        //xpTools.printHash(xpEvent);
    }
}

/* **********************************************************************
* 						ENDING Event code-block
********************************************************************** */

/* **********************************************************************
* 						STARTING Node lookup code-block
********************************************************************** */
/**
 * Looks for a device type on the net
 * @method lookupDevices
 * @param  {string}      type The device type to look for. It potentially returns a set of devices.
 * @param  {xpNode}      objRef A reference to access a specific xpNode datagram socket.
 * @return {Set} If found, returns a set of devices with the specified type, null otherwise
 */
xpNode.prototype.lookupDevices = function(type, objRef) {
    var start = new Date().getTime();
    var retVal = new Array();
    for(var i = 0 ; i < objRef.announcesList.length; i++) {
        var iThElement = objRef.announcesList[i];
        if(iThElement['device_type'] == type) {
            retVal.push(iThElement);
        }
    }
    if(retVal.length > 0) {
        xpTools.xpLog(false, "\tFound " + retVal.length + " nodes\n");
        return retVal;
    }
    return null;
}

/**
 * Looks for a specificed device on the net by its name
 * @method lookupDevices
 * @param  {string}      name The device name to look for in the xPlaces network.
 * @param  {xpNode}      objRef A reference to access a specific xpNode datagram socket.
 * @return {Hashtable} If found, returns a device with the specified name, null otherwise
 */
xpNode.prototype.lookupDevice = function(name, objRef) {
    var start = new Date().getTime();
    for(var i = 0 ; i < objRef.announcesList.length; i++) {
        var iThElement = objRef.announcesList[i];
        if(iThElement['device_name'] == name) {
            //xpTools.xpLog(false, "\tFound node " + iThElement['device_name'] + " on ip: " + iThElement['sender_ip_port'] + "\n");
            return iThElement;
        }
    }
    return null;
}
/**
 * Lookup device implementation but blocking
 * @method lookupDeviceWaiting
 * @param  {string}            name The device name to look for in the xPlaces network.
 * @param  {xpNode}            objRef A reference to access a specific xpNode datagram socket.
 * @return {Hashtable} If found, returns a device with the specified name, null otherwise
 */
xpNode.prototype.lookupDeviceWaiting = function(name, objRef) {
    var iterations = 0;

    var nonBlockingSendingFunc = function(name, objRef, callback, iterations) {
        if(iterations <= 20) {
            var destination = objRef.lookupDevice(name, objRef);
            if(destination != null) {
                return destination;
            } else {
                iterations++;
                setTimeout(callback, 1000, name, objRef, callback, iterations);
            }
        } else {
            return null;
        }
    }

    setTimeout(nonBlockingSendingFunc, 1, name, objRef, nonBlockingSendingFunc, iterations);
}


/* **********************************************************************
* 						ENDING Node lookup code-block
********************************************************************** */
/**
 * Prints a message received from WebSocket. Used internally for debuggin'
 * @method printMessageFromWebSocket
 * @param  {string}                  message The message received from remote endpoint of local WSocket.
 *
 */
xpNode.prototype.printMessageFromWebSocket = function(message) {
    xpTools.xpTools.xpLog(false, message);
}

module.exports = xpNode;